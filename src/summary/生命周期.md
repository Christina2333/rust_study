定义：
rust中每一个引用都有其生命周期（lifetime），即引用保持有效的作用域。

大部分时候，引用的生命周期是隐含可以推断的，但也会出现生命周期以不同的方式关联的情况，此时需要使用范型生命周期参数标注关系。

##### 借用检查器（borrow checker）
用处：比较作用域来确保所有的借用都是有效的。引用的数据需要比引用存活的时间长，才能通过编译。避免悬垂引用（指向的数据被释放了，引用还在）
如下所示，借用j检查器会认为下面代码编译失败，因为数据（x）的生命周期 比指向他的引用（r） 的生命周期还短。
`
{
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {}", r); //          |
}                         // ---------+
`

#### 生命周期注解语法
生命周期注解不会改变任何引用的生命周期长短。
因为生命周期注解告诉rust多个引用的范型和生命周期参数如何相互联系，所以单个生命周期注解本身没有意义。

##### 函数签名中的生命周期注解
通过在函数签名中指定生命周期参数时，并没有改变任何传入值或返回值的生命周期，而是指出任何不满足这个约束条件的值都将被借用检查器拒绝。
之所以要标注函数入参和返回值的生命周期，是因为rust自身无法分析出参数和返回值的生命周期，因为每次函数被调用时，其生命周期都可能不同。
如下例子所示：返回值的引用生命周期'a表名，返回值的生命周期和入参x、y中生命周期最短的生命周期相同。
`
fn main() {
    fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
        if x.len() > y.len() {
            x
        } else {
            y
        }
    }
}
`
因此下面代码无法通过编译，按照函数签名，result的生命周期应该等同于string2的生命周期（string1和string2中string2生命周期最短），
所以在println()中引用result时会报错，因此此时result的生命周期已经结束。
`
fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {}", result);
}
`

##### 结构体定义中的生命周期注解
需要为结构体中每个引用添加生命周期注解。

##### 生命周期省略规则（lifetime elision rule）
rust团队发现了在特定场景下，开发者们需要编写一样的生命周期注解，因此把这些可预测的、遵循明确模式的规则编写到了rust编译器中。
使得在某些情况下，编译器可以推断出生命周期。

**输入生命周期**
函数或方法参数的生命周期。
**输出生命周期**
函数或方法返回值的生命周期。

（1）适用于输入生命周期，每个引用的参数都有自己的生命周期参数。例如`fn foo<'a, 'b>(x: &'a i32, y: &'b i32)`
（2）适用于输出生命周期，如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数。例如：`fn foo<'a>(x: &'a i32) -> &'a i32`
（3）适用于输出生命周期，如果方法有多个输入生命周期参数，且其中一个是&self或者&mut self（即对象方法），那么所有输出生命周期参数被赋予self的生命周期。

##### 方法定义中生命周期注解
`
fn main() {
    struct ImportantExcerpt<'a> {
        part: &'a str,
    }
    impl<'a> ImportantExcerpt<'a> {
        fn level(&self) -> i32 {
            3
        }
    }
}
`

#### 静态生命周期
'static，其生命周期能够存活与整个程序期间。所有的字符串字面值都拥有 'static 生命周期
